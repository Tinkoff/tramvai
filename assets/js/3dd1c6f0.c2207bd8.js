"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8655],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>u});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),l=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=l(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),h=l(a),u=r,m=h["".concat(s,".").concat(u)]||h[u]||c[u]||i;return a?n.createElement(m,o(o({ref:t},d),{},{components:a})):n.createElement(m,o({ref:t},d))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=h;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"==typeof e?e:r,o[1]=p;for(var l=2;l<i;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},1442:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>p,metadata:()=>l,toc:()=>c});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),o=["components"],p={id:"papi",title:"Papi (API Routes)"},s=void 0,l={unversionedId:"features/papi",id:"features/papi",title:"Papi (API Routes)",description:"Papi - API routes for the tramvai application. The functionality is included in the module @tramvai/module-server with the help of @tramvai/papi",source:"@site/tmp-docs/03-features/016-papi.md",sourceDirName:"03-features",slug:"/features/papi",permalink:"/docs/features/papi",draft:!1,editUrl:"https://github.com/Tinkoff/tramvai/-/edit/master/docs/get-started/overview.md/tmp-docs/03-features/016-papi.md",tags:[],version:"current",sidebarPosition:16,frontMatter:{id:"papi",title:"Papi (API Routes)"},sidebar:"sidebar",previous:{title:"Add Child App without CLI",permalink:"/docs/features/child-app/advanced/add-child-app-without-cli"},next:{title:"PWA (Progressive Web App)",permalink:"/docs/features/pwa"}},d={},c=[{value:"Explanation",id:"explanation",level:2},{value:"Usage",id:"usage",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Automatic handler creation",id:"automatic-handler-creation",level:3},{value:"Creating a handler via provider",id:"creating-a-handler-via-provider",level:3},{value:"How to",id:"how-to",level:2},{value:"Create simple papi",id:"create-simple-papi",level:3},{value:"Use parameters of the request",id:"use-parameters-of-the-request",level:3},{value:"Settings headers and status",id:"settings-headers-and-status",level:3},{value:"Use deps",id:"use-deps",level:3},{value:"Use cache with deps",id:"use-cache-with-deps",level:3},{value:"How to get data from papi?",id:"how-to-get-data-from-papi",level:3},{value:"How can I get data from DI in papi routes?",id:"how-can-i-get-data-from-di-in-papi-routes",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"createPapiMethod",id:"createpapimethod",level:3},{value:"handler",id:"handler",level:4},{value:"isPapiMethod",id:"ispapimethod",level:3}],h={toc:c};function u(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Papi - API routes for the ",(0,i.kt)("inlineCode",{parentName:"p"},"tramvai")," application. The functionality is included in the module ",(0,i.kt)("a",{parentName:"p",href:"/docs/references/modules/server"},"@tramvai/module-server")," with the help of ",(0,i.kt)("a",{parentName:"p",href:"/docs/references/tramvai/papi"},"@tramvai/papi")),(0,i.kt)("h2",{id:"explanation"},"Explanation"),(0,i.kt)("p",null,"Often, an application needs microservices that can process user requests and return JSON responses. It is to address these cases that PAPIs were developed. PAPI allows you to implement request handlers that clients can request and receive a response in an arbitrary format, for example, JSON. PAPI allows you to quickly and cheaply implement handlers without raising additional microservices."),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("h3",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("p",null,"You need to install ",(0,i.kt)("inlineCode",{parentName:"p"},"@tramvai/papi")," library:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"npx tramvai add @tramvai/papi\n")),(0,i.kt)("h3",{id:"automatic-handler-creation"},"Automatic handler creation"),(0,i.kt)("p",null,"Let's consider on the basis of the case: it is necessary to create a separate api service which, according to an url like ",(0,i.kt)("inlineCode",{parentName:"p"},"${APP_ID}/papi/getSum")," will return the sum of the passed parameters a and b"),(0,i.kt)("p",null,"Based on the configuration parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"<app>.serverApiDir")," in tramvai.json (by default folder ",(0,i.kt)("inlineCode",{parentName:"p"},"./src/api"),") the directory where the papi handlers are stored is determined. Create a new file in this folder with the name of our new handler, i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"getSum.ts")," for our example. The default export from the file will be used as a handler, create it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createPapiMethod } from '@tramvai/papi';\n\nexport default createPapiMethod({\n  async handler() {\n    return 'hello';\n  },\n});\n")),(0,i.kt)("p",null,"We restart the server so that the new handler is added to the papi list. The result of the function call will be used as the body of the response, so now if we turn to the address ",(0,i.kt)("inlineCode",{parentName:"p"},"http://localhost:3000/tincoin/papi/getSum"),", then in the response we will receive an object with the property ",(0,i.kt)("inlineCode",{parentName:"p"},"payload: 'hello'"),"."),(0,i.kt)("p",null,"Next, let's add logic to our handler:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createPapiMethod } from '@tramvai/papi';\nimport { PAPI_CACHE_TOKEN } from '../tokens'; // one of the app-defined tokens\n\n// eslint-disable-next-line import/no-default-export\nexport default createPapiMethod({\n  async handler({ body, requestManager }) {\n    const { cache } = this.deps;\n    const method = requestManager.getMethod();\n    const { a, b } = body;\n\n    if (method !== 'POST') {\n      throw new Error('only post methods');\n    }\n\n    if (!a || !b) {\n      return {\n        error: true,\n        message: 'body parameters a and b should be set',\n      };\n    }\n\n    const key = `${a},${b}`;\n\n    if (cache.has(key)) {\n      return { error: false, fromCache: true, result: cache.get(key) };\n    }\n\n    const result = +a + +b;\n\n    cache.set(key, result);\n\n    return { error: false, fromCache: false, result };\n  },\n  deps: {\n    cache: PAPI_CACHE_TOKEN,\n  },\n});\n")),(0,i.kt)("p",null,"There is no need to restart the build, @tramvai/cli will rebuild everything itself after saving the changes to disk. Now you can make a POST request to ",(0,i.kt)("inlineCode",{parentName:"p"},"http://localhost:3000/tincoin/papi/getSum"),", pass the parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," and get the result."),(0,i.kt)("h3",{id:"creating-a-handler-via-provider"},"Creating a handler via provider"),(0,i.kt)("p",null,"If you need to use other application dependencies from di in the handler, you can add a provider with the ",(0,i.kt)("inlineCode",{parentName:"p"},"SERVER_MODULE_PAPI_PUBLIC_ROUTE")," token:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"// ...\nimport { createPapiMethod } from '@tramvai/papi';\nimport { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/tokens-server';\nimport { provide } from '@tramvai/core';\n\ncreateApp({\n  // ...\n  providers: [\n    // ...\n    provide({\n      provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE,\n      multi: true,\n      useFactory: () => {\n        return createPapiMethod({\n          method: 'get',\n          path: '/ping',\n          async handler() {\n            this.log.error('/ping requested'); // log with the error level to see the log for sure\n            return 'pong';\n          },\n        });\n      },\n    }),\n  ],\n});\n")),(0,i.kt)("p",null,"Now you can make a request to the address ",(0,i.kt)("inlineCode",{parentName:"p"},"http://localhost:3000/tincoin/papi/ping"),", in the response we will receive an object with the property ",(0,i.kt)("inlineCode",{parentName:"p"},"payload: 'pong'"),",  in the terminal with the running process ",(0,i.kt)("inlineCode",{parentName:"p"},"tramvai start ${APP_ID}")," we will see the error log ",(0,i.kt)("inlineCode",{parentName:"p"},"/ping requested"),"."),(0,i.kt)("h2",{id:"how-to"},"How to"),(0,i.kt)("h3",{id:"create-simple-papi"},"Create simple papi"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createPapiMethod } from '@tramvai/papi';\n\nexport const papi = createPapiMethod({\n  // will handle requests to `/app/papi/my/papi` (actual url depends on setup)\n  path: '/my/papi',\n  // only requests with GET http method will be handled\n  method: 'get',\n  // function to return response to the client\n  async handler() {\n    return 'test';\n  },\n});\n")),(0,i.kt)("h3",{id:"use-parameters-of-the-request"},"Use parameters of the request"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createPapiMethod } from '@tramvai/papi';\n\nexport const papi = createPapiMethod({\n  async handler({ parsedUrl: { query }, cookies }) {\n    const { a, b } = query;\n    const { testCookie } = cookie;\n\n    return {\n      testCookie,\n      a,\n      b,\n    };\n  },\n});\n")),(0,i.kt)("h3",{id:"settings-headers-and-status"},"Settings headers and status"),(0,i.kt)("p",null,"It can be done with ",(0,i.kt)("a",{parentName:"p",href:"/docs/references/tokens/common#responsemanager-tokens"},"responseManager")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createPapiMethod } from '@tramvai/papi';\n\nexport const papi = createPapiMethod({\n  async handler({ responseManager }) {\n    responseManager.setHeader('content-type', 'text/html');\n    responseManager.setStatus(200);\n\n    return `<html>...</html>`;\n  },\n});\n")),(0,i.kt)("h3",{id:"use-deps"},"Use deps"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createPapiMethod } from '@tramvai/papi';\n\nexport const papi = createPapiMethod({\n  async handler() {\n    const { cookieManager } = this.deps;\n\n    cookieManager.set({ name: 'b', value: 'abc', expires: 35 });\n\n    return 'response';\n  },\n  deps: {\n    cookieManager: COOKIE_MANAGER_TOKEN,\n  },\n});\n")),(0,i.kt)("h3",{id:"use-cache-with-deps"},"Use cache with deps"),(0,i.kt)("p",null,"Deps are resolved with ChildContainer that means they are getting resolved on every request in order to provide request specific info. To use any of deps that should outlive scope of the request you should use provider that was initialized with ",(0,i.kt)("a",{parentName:"p",href:"/docs/concepts/di#root-container"},"scope=SINGLETON")),(0,i.kt)("p",null,"For example, if you want to use some papi specific cache you should create new token and provide the cache instance with that token and with option ",(0,i.kt)("inlineCode",{parentName:"p"},"scope: Scope.SINGLETON")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createToken, Scope, provide } from '@tinkoff/dippy';\nimport { createApp } from '@tramvai/core';\nimport { createPapiMethod } from '@tramvai/papi';\nimport { Cache, CREATE_CACHE_TOKEN } from '@tramvai/tokens-common';\n\nexport const PAPI_CACHE_TOKEN = createToken<Cache<string>>('app papi cache');\n\nconst app = createApp({\n  // ...,\n  providers: [\n    // ...,\n    provide({\n      provide: PAPI_CACHE_TOKEN,\n      scope: Scope.SINGLETON,\n      useFactory: ({ createCache }) => {\n        return createCache('memory');\n      },\n      deps: {\n        createCache: CREATE_CACHE_TOKEN,\n      },\n    }),\n  ],\n});\n\nexport const papi = createPapiMethod({\n  async handler({ parsedUrl: { query } }) {\n    const { cacheKey } = query;\n    const { cache } = this.deps;\n\n    if (cache.has(cacheKey)) {\n      return cache.get(cacheKey);\n    }\n\n    const result = heavyComputation();\n\n    cache.set(cacheKey, result);\n\n    return result;\n  },\n  deps: {\n    cache: PAPI_CACHE_TOKEN,\n  },\n});\n")),(0,i.kt)("h3",{id:"how-to-get-data-from-papi"},"How to get data from papi?"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"papi")," is available at ",(0,i.kt)("inlineCode",{parentName:"p"},"/${appInfo.appName}/papi"),". This url was chosen because it would divide many different papi services into 1 application domain."),(0,i.kt)("p",null,"For the example above with adding a route, the resulting url will look like this: ",(0,i.kt)("inlineCode",{parentName:"p"},"/${appInfo.appName}/papi/test")," where appName is the name passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"createApp")),(0,i.kt)("p",null,"To make a request, you need to use ",(0,i.kt)("inlineCode",{parentName:"p"},"PAPI_SERVICE")," from the module ",(0,i.kt)("inlineCode",{parentName:"p"},"@tramvai/module-http-client"),", which automatically on the client will make an http request to papi and on the server will simply call the handler function"),(0,i.kt)("h3",{id:"how-can-i-get-data-from-di-in-papi-routes"},"How can I get data from DI in papi routes?"),(0,i.kt)("p",null,"For the papi handler, it is possible to set the dependencies that it needs to work. Thus for each call a separate child di-container will be created, which will allow using both ",(0,i.kt)("inlineCode",{parentName:"p"},"SINGLETON")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"REQUEST")," dependencies."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Module, provide } from '@tramvai/core';\nimport { CREATE_CACHE_TOKEN } from '@tramvai/module-common';\nimport { HTTP_CLIENT } from '@tramvai/module-http-client';\nimport { SERVER_MODULE_PAPI_PUBLIC_ROUTE } from '@tramvai/module-server';\nimport { createPapiMethod } from '@tramvai/papi';\n\n@Module({\n  providers: [\n    provide({\n      provide: SERVER_MODULE_PAPI_PUBLIC_ROUTE,\n      multi: true,\n      useFactory: ({ createCache }) => {\n        const cache = createCache(); // cache must be common for all handler calls, so we call it outside of createPapiMethod\n\n        return createPapiMethod({\n          path: '/my/papi',\n          method: 'post',\n          async handler({ httpClient }) {\n            // use what was requested in deps from createPapiMethod\n            if (cache.has('test')) {\n              return 'test';\n            }\n\n            const { payload } = await httpClient.get('fake');\n            return payload;\n          },\n          deps: {\n            httpClient: HTTP_CLIENT, // the same dependency must be recreated for each call and they must be independent\n          },\n        });\n      },\n      deps: {\n        createCache: CREATE_CACHE_TOKEN, // this is a dependency from the root container, which will be created only once\n      },\n    }),\n  ],\n})\nexport class PapiTestModule {}\n")),(0,i.kt)("h2",{id:"api-reference"},"API Reference"),(0,i.kt)("h3",{id:"createpapimethod"},"createPapiMethod"),(0,i.kt)("p",null,"Options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"path")," - specifies the path of url that current papi should handle. Required when specifying papi in tramvai DI, and not used when specified through file api."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"method"),' - specified HTTP-method that is acceptable by current papi. By default, it equals to "all"'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"handler")," - see ",(0,i.kt)("a",{parentName:"li",href:"#handler"},"handler")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deps")," - any DI deps that papi may require"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"options")," - additional options that controls how current papi works",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"timeout")," - timeout for executing current papi. If timeout exceeded request is resolved with Execution timeout error.")))),(0,i.kt)("h4",{id:"handler"},"handler"),(0,i.kt)("p",null,"Function that accepts the details of the request and should return the response"),(0,i.kt)("p",null,"Details of the request are passed with first parameter when handler is called. You can see available properties in typings when specifying papi method. It should provide most of the data that might be required to handle the request."),(0,i.kt)("p",null,"Additionally, through ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," you can get data that bounded to papi method:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"deps")," - resolved deps that were specified when defining papi method. Deps are resolved with ",(0,i.kt)("a",{parentName:"li",href:"/docs/concepts/di#container-is-a-child"},"Child DI Container"),", so do not use it for creating caches as it won't work."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"log")," - instance of ",(0,i.kt)("a",{parentName:"li",href:"/docs/references/modules/log#logger_token"},"LOGGER_TOKEN")," bounded with current papi method")),(0,i.kt)("h3",{id:"ispapimethod"},"isPapiMethod"),(0,i.kt)("p",null,"Type guard to check is passed object is papi handler"))}u.isMDXComponent=!0}}]);