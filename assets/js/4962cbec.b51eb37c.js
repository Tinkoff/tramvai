"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[534],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),d=l(t),m=o,y=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return t?r.createElement(y,a(a({ref:n},c),{},{components:t})):r.createElement(y,a({ref:n},c))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=d;var p={};for(var s in n)hasOwnProperty.call(n,s)&&(p[s]=n[s]);p.originalType=e,p.mdxType="string"==typeof e?e:o,a[1]=p;for(var l=2;l<i;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},9043:(e,n,t)=>{t.r(n),t.d(n,{frontMatter:()=>p,contentTitle:()=>s,metadata:()=>l,toc:()=>c,default:()=>d});var r=t(7462),o=t(3366),i=(t(7294),t(3905)),a=["components"],p={id:"strong-typing",title:"Strong typing"},s=void 0,l={unversionedId:"guides/strong-typing",id:"guides/strong-typing",title:"Strong typing",description:"Introduction",source:"@site/tmp-docs/guides/strong-typing.md",sourceDirName:"guides",slug:"/guides/strong-typing",permalink:"/docs/guides/strong-typing",editUrl:"https://github.com/Tinkoff/tramvai/-/edit/master/docs/get-started/overview.md/tmp-docs/guides/strong-typing.md",tags:[],version:"current",frontMatter:{id:"strong-typing",title:"Strong typing"},sidebar:"sidebar",previous:{title:"Storybook integration",permalink:"/docs/guides/storybook"},next:{title:"actions-conditions",permalink:"/docs/how-to/actions-conditions"}},c=[{value:"Introduction",id:"introduction",children:[{value:"Dependency Injection",id:"dependency-injection",children:[{value:"Modules",id:"modules",children:[],level:4},{value:"Tokens",id:"tokens",children:[],level:4},{value:"Providers",id:"providers",children:[],level:4},{value:"React components",id:"react-components",children:[],level:4}],level:3}],level:2}],u={toc:c};function d(e){var n=e.components,t=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"tramvai")," has written on TypeScript, and we try to provide first-class developer experience with better typings and automatic type inference.\nNonetheless, perfect typings requires some specific utilities and recipes."),(0,i.kt)("h3",{id:"dependency-injection"},"Dependency Injection"),(0,i.kt)("p",null,"Complete information about ",(0,i.kt)("inlineCode",{parentName:"p"},"tramvai")," DI system you can find in ",(0,i.kt)("a",{parentName:"p",href:"/docs/concepts/di"},"Concepts section"),"."),(0,i.kt)("h4",{id:"modules"},"Modules"),(0,i.kt)("p",null,"First place, when we need to have a good typings - is list of providers in ",(0,i.kt)("inlineCode",{parentName:"p"},"tramvai")," modules.\nThis possible when providers wrapped in the ",(0,i.kt)("inlineCode",{parentName:"p"},"provide")," utility:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { provide, optional } from '@tramvai/core';\n\nconst BOOLEAN_TOKEN = createToken<boolean>('boolean');\nconst NUMBER_TOKEN = createToken<number>('number');\n\n@Module({\n    providers: [\n        provide({\n            provide: NUMBER_TOKEN,\n            // wrong value type, TS compilation error\n            useValue: '0',\n        }),\n        provide({\n            provide: BOOLEAN_TOKEN,\n            useFactory: (deps) => {\n                // deps.int type is number, TS compilation error\n                return deps.int === '0';\n            },\n            deps: {\n                int: NUMBER_TOKEN,\n            },\n        }),\n        // example with optional dependency\n        provide({\n            provide: BOOLEAN_TOKEN,\n            useFactory: (deps) => {\n                // optional dependency will infer as `number | null`\n                return typeof deps.int === 'number' ? deps.int > 0 : false;\n            },\n            deps: {\n                int: optional(NUMBER_TOKEN),\n            },\n        }),\n    ],\n})\nexport class SomeModule {}\n")),(0,i.kt)("h4",{id:"tokens"},"Tokens"),(0,i.kt)("p",null,"Always create tokens with specific type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const BOOLEAN_TOKEN = createToken<boolean>('boolean');\n\nconst API_SERVICE_TOKEN = createToken<ApiService>('boolean');\n\ninterface ApiService {\n    request<R>(): Promise<R>;\n}\n")),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"multi")," tokens, use the same type as you expect to provide in DI, ",(0,i.kt)("strong",{parentName:"p"},"not")," array of types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// good\nconst LIST_TOKEN = createToken<string>({ name: 'list', multi: true });\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// bad\nconst LIST_TOKEN = createToken<string[]>({ name: 'list', multi: true });\n")),(0,i.kt)("p",null,"When you need infer a token type to ",(0,i.kt)("strong",{parentName:"p"},"implement")," this interface, use ",(0,i.kt)("inlineCode",{parentName:"p"},"ExtractTokenType")," utility:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import type { ExtractTokenType } from '@tinkoff/dippy';\n\nconst BOOLEAN_TOKEN = createToken<boolean>('boolean');\nconst LIST_TOKEN = createToken<string>({ name: 'list', multi: true });\n\n// boolean\ntype SomeBoolInterface = ExtractTokenType<typeof BOOLEAN_TOKEN>;\n\n// string\ntype SomeListInterface = ExtractTokenType<typeof LIST_TOKEN>;\n")),(0,i.kt)("p",null,"When you need infer a token type as dependency, e.g. in ",(0,i.kt)("strong",{parentName:"p"},"arguments"),", use ",(0,i.kt)("inlineCode",{parentName:"p"},"ExtractDependencyType")," utility, this helper return array of types for ",(0,i.kt)("inlineCode",{parentName:"p"},"multi")," tokens, because array of values will return from DI:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import type { ExtractDependencyType } from '@tinkoff/dippy';\n\nfunction someFn(deps: {\n    bool: ExtractDependencyType<typeof BOOLEAN_TOKEN>,\n    list: ExtractDependencyType<typeof LIST_TOKEN>\n}) {\n    deps.bool; // boolean\n    deps.list; // string[]\n}\n")),(0,i.kt)("h4",{id:"providers"},"Providers"),(0,i.kt)("p",null,"Sometimes you need to write providers class or factories outside modules - for code maintainability and testing purposes.\nFor these cases, you will need to manually type values and deps with ",(0,i.kt)("inlineCode",{parentName:"p"},"ExtractTokenType")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ExtractDependencyType")," utilities."),(0,i.kt)("p",null,"Factory example with ",(0,i.kt)("inlineCode",{parentName:"p"},"multi")," tokens:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import type { ExtractTokenType, ExtractDependencyType } from '@tinkoff/dippy';\n\n// import this tokens from some other packages\nconst FOO_TOKEN = createToken<number>({ name: 'foo', multi: true });\nconst BAR_TOKEN = createToken<number>({ name: 'bar', multi: true });\n\n// factory deps\ntype Deps = {\n    bar: ExtractDependencyType<typeof BAR_TOKEN>;\n}\n\n// factory return type\ntype Result = ExtractTokenType<typeof FOO_TOKEN>;\n\nexport function fooFactory(deps: Deps): Result {\n    return [...deps.bar];\n}\n")),(0,i.kt)("p",null,"Class example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import type { ExtractTokenType, ExtractDependencyType } from '@tinkoff/dippy';\n\n// import this tokens from some other packages\nconst API_SERVICE_TOKEN = createToken<AbstractApiService>('boolean');\nconst LIST_TOKEN = createToken<string>({ name: 'list', multi: true });\n\n// class constructor deps\ntype Deps = {\n    list: ExtractDependencyType<typeof LIST_TOKEN>;\n}\n\n// class interface\ntype IApiService = ExtractTokenType<typeof API_SERVICE_TOKEN>;\n\nexport class ApiService implements IApiService {\n    // reuse Deps interface for simplicity\n    private list: Deps['list'];\n\n    constructor(deps: Deps) {\n        this.list = deps.list;\n    }\n}\n")),(0,i.kt)("h4",{id:"react-components"},"React components"),(0,i.kt)("p",null,"For React components, you can use hook ",(0,i.kt)("a",{parentName:"p",href:"/docs/references/tramvai/react#usedi"},"useDi"),".\nWith this hook, all types will be inferred automatically:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { optional } from '@tramvai/core';\nimport { useDi } from '@tramvai/react';\n\nconst LIST_TOKEN = createToken<string>({ name: 'list', multi: true });\n\nconst Component = () => {\n    // string[]\n    const a = useDi(LIST_TOKEN);\n    // string[] | null\n    const b = useDi(optional(LIST_TOKEN));\n    // string[]\n    const { list: c } = useDi({ list: LIST_TOKEN });\n    // string[] | null\n    const { list: d } = useDi({ list: optional(LIST_TOKEN) });\n\n    return null;\n}\n")))}d.isMDXComponent=!0}}]);